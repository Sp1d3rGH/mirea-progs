
# Практическое занятие 1

## Некоторые важные встроенные функциии языка Julia

1. C помощью встроенной помощи (help?>) изучить назначение и способы использования следующих встроенных функций julia:

- zeros, ones, fill, rand
- size, length
- collect
- Array, Vector, Matrix
- similar
- eltype
- copy, deepcopy

2. C помощью встроенной помощи (help?>) изучить назначение и способы использования следующих встроенных функций julia:

- findall, findfirst, findlast
- filter

Самостоятельно реализовать все эти функции на языке Julia

3. C помощью встроенной помощи (help?>) изучить назначение и способы использования следующих встроенных функций julia:

- issorted
- sort!(a), sort(a)
- sortperm!(a), sortperm(a)

Самостоятельно реализовать функцию issorted на языке Julia.

## Сортирвка методом "пузырька"

По аналогии со встроенными функциями сортировки реализовать следующие 4 вида функций сортировки на базе агоритма сортировки методом "пузырька".

```julia
function bubblesort!(a)
    n = length(a)
    for k in 1:n-1
        is_sorted = true
        for i in 1:n-k
            if a[i]>a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
                is_sorted = false
            end
        end
        if is_sorted
            break
        end
    end
    return a
end

bubblesort(a) = bubblesort!(deepcopy(a))

function bubblesortperm!(a)
    n = length(a)
    indexes = collect(1:n)
    for k in 1:n-1
        is_sorted = true
        for i in 1:n-k
            if a[i] > a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
                indexes[i], indexes[i+1] = indexes[i+1], indexes[i]
                is_sorted = false
            end
        end
        if is_sorted
            break
        end
    end
    return indexes
end
bubblesortperm(a) = bubblesortperm!(deepcopy(a))

```

## Массивы в Julia с произвольным способом индексации

Индексация стандартных массивов в Julia  начинается с 1 (в отличие от языка Python или С/C++, где индексация начинается с 0). Такое решение разработчики языка приняли потому, что язык Julia в первую очередь ориентирован на математические вычисления, а в математике принято нумерацию эементов векторов, строк и столбцов матриц начинать с единицы. Однако в Julia имеется возможность определять массивы с произвольными границами индексов, это  массивы типа OffsetArray. Данный тип определен в отдельном пакете OffsetArrays.jl (требующий отдельной установки: pkg> add OffsetArrays).

Например, если имеется обычный массив

```julia
A = [10, 20, 30,40, 50]
```

то превратить его в массив с границами индексов -2:2 можно следующим образом

```julia
using OffsetArrays
A2 = OffsetArray(A, -2:2)
```

Тогда

```julia
A2[-2]  #- это 10
A2[-1]  #- это 20
A2[0]   #- это 30
A2[1]   #- это 40
A2[2]   #- это 50
```

Аналогично можно задать требуемые диапазоны индексов строк и столбцов матрицы (в этом случаее в конструктор OffsetArray потребовалось бы передать уже не один, а два диапазона индексов).

## Способ программирования в Julia без привязки к способу индексации

Если мы ходим иметь работающий код, который не будет приязан к тому, с какого значения индекса начинается индексация массива, то следует пользоваться специальными встроенными функциями: first, firstindex, last, lastindex, nextindex и специальными зарезервированными словами begin, end, которые в контексте индексного выражения обозначают первый и последний индекс массива, соответственно. Например:

```julia
function bubblesort!(a)
    n = length(a)
    for k in 1:n-1
        is_sorted = true
        for i in firstindex(a):lastindex(a)-k
            if a[i] > a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
                is_sorted = false
            end
        end
        if is_sorted
            break
        end
    end
    return a
end
```

## Срезы массивов

Любой массив имеет какое-то число измерений (индексов), dims(A) - встроенная функция, возвращающая число измерений массива A. В частности, если dims(A)==1, то такой массив мы называем вектором, если dims(A)==2, то - матрицей. Всё сказанное в этом параграфе относится к массивам любого числа измерений, но для определенности будем считать, что dims(A)==2.

Срезом массива называют массив, состоящий из элементов данного массива, и получаемый из данного массива с помощью указания соответствующих диапазонов индексов, и/или векторных индексов. Более подробно рассмотрим это на конкретном примере.

Пусть, например,

```julia
A = [10 20 30 40 50
     60 70 80 90 95
     15 25 35 45 55
     65 75 85 96 97]
```

Тогда, например,

```julia
    A[2,3] # - это число 70 
    A[2,3] = 0 # - число 70 заменяется значением 0
```

Выражение A[2,3] можно рассматривать как пример простейшего среза, выделяющего из массива один единственный элемент. Но возможны и срезы, состоящие из многих элементов массива. Рассмотрим некоторые другие примеры срезов массива A:

```julia
A[[1,3],[2,4,5,2]] # - это срез, представляющий собой массив, составленный из элементов массива `A`:

[ A[1,2] A[1,4] A[1,5] A[1,2]
  A[1,2] A[1,4] A[1,5] A[1,2] ]
```

(если строки матрицы записаны одна под другой, то в записи матрицы ставить разделитель строк ";" не обязательно)

Как видим, срез может включать и повторяющиеся элементы исходного массива.

Срез формируется путем копирования элементов данного массива в новую область памяти.

**Задача.** Написать функцию, формирующую срез заданной матрицы по заданным наборам индексов - имеется ввиду без использования конструкции A[I,J], где I,J - два заданных набора индексов (в примере выше, например, I=[1,2], J=[2,4,5,2]).

Решение.

```julia
function slice(A::Matrix,I::Vectot{Int},J::Vector{Int})
    B=Matrix{eltype(A)}(undef,length(I),length(J))
    for i in I
        for j in J
            B[i,j]=A[I[i],J[j]]
        end
    end
    return B
end
```

**Замечание 1.** Встроенная функция eltype(A) возвращает тип элементов массива A (вязыке Julia скалярные значения совместимы с массивами размера "1 на 1", поэтому данную функцию можно применять не только к маасивам, но и к скалярам). Конструктор Matrix{Type} - это синоним Array{Type,2} (Type - это имя какого-либо типа), также как и Vector{Type} - это синоним Array{Type,1}. Запись Matrix{eltype(A)}(undef,length(I),length(J)) - означает, что вызывается конструктор Matrix{Type} со своими фактическими аргументами. При формировании числовых массивов первый аргумент всегда имеет значение undef, что означает, что элементы массива не инициализируются (их значения являются, как принято говорить, просто "информационным мусором"). Два последних аргумента - определяют размер создаваемого массива; допускается передавать размеры массива также в виде одного кортежа.

**Замечание .** Иногда, когда имеется некоторый массив A и требуется сформировать неинициализированный массив B того же типа и размера, то вместо B=Array{eltype(A),ndims(A)}(undef,size(A)) можно воспользоваться специальной встроенной функцией B=similar(A).

Использовать для той же цели функцию zeros (или ей подобную, например, ones) не целесообразно, поскольку операция инициализации массива - не "бесплатная". Однако если требуется именно инициализация массива, то наряду с функциями zeros и ones имеется встроенная функция fill, обеспечивающая инициализациию всех элементов массива каким-либо заданным значением, напрример: fill(value, size), где value - заданное значение, size - кортеж, содержащий размеры создаваемого массива. При этом тип массива будет совпадать с типом значения value; допускается также размеры массива передавать не в кортеже, а отдельными значениями, например, в случаее двумерноного массива: fill(value, size_1, size_2).

## Ссылки на срезы массива, функция view (макрос @view)

В языке Julia любой срез является копией некоторой части заданного массива, т.е. другим массивом.

Однако часто требуется получить ссылку на часть заданного массива, причем так, чтобы работать с этой ссылкой формально можно было бы так же как с отдельным массивом. Для этой цели в языке Julia пердусмотрена встроенная функция view. Например,

```julia
A=[10 20 30
   40 50 60
   70 80 90]
   
B = view(A,:,2)

# B - это ссылка на срез A[:,2]:

B[1]=0
println(A)
  [10  0 30
   40 50 60
   70 80 90]
```

Вместо вызовов функции view более удобно пользоваться соответствующим макросом @view, например:

```julia
B = @view A[:,2]
```

результат будет в точности тот же.

## Пример исспользования ссылок на срезы

**Задача.** Требуется написать функцию, осуществляющую сортировку каждого столбца матрицы по отдельности методом "пузырька".

**Указание.** Для этой функции использовать тоже самое имя, что и для функции осуществляющей сортировку вектора методом "пузырька", воспользовавшись механизмом множественной диспетчеризации языка Julia.

**Решение.**

```julia
function bubblesort!(A::AbstractMatrix)
    for j in size(A,2)
        bubblesort!(@view A[:,j]) # - осуществляется сортировка j-го столбца с помощью ранее написанной функции
    end
    return A
end
```

Следующая функция реализуют сортировку копии исходного массива

```julia
bubblesort(A::AbstractMatrix{T}) where T <: Union{Real,Char,String} = bubblesort!(copy(A))
```

Каждая из следующих двух функций возвращают матрицу, столбцы которой содержат перестрановку индексов элементов соответствующих столбцов, произошедших в результате их сортировок (методом "пузырька").

```julia
function bubblesortperm!(A::A::AbstractMatrix{T}) where T <: Union{Real,Char,String}
    indexes = Matrix{Int}(undef,size(A)) 
    for j in size(A,2)
        indexes[:,j] = bubblesortperm!(@view A[:,j]) 
    end
    return indexes
end

bubblesortperm(A::AbstractMatrix{T}) where T <: Union{Real,Char,String} = bubblesortperm!(deepcopy(A))
```

**Замечание 1.** Если вместо сортировки столбцов матрицы требуется выполнить сортировку её строк, то это можно будет реализовать с помощью уже имеющихся функций, использую операцию транспонирования.

**Замечание 2.** Сортирвать строки матрицы непосредственно было бы нежелательно по следующим двум причинам.

Во-первых, поскольку срез матрицы, являющийся её строкой - это в формальном отношении двумерный, а не одномерный массив, то для сортировки строк матрицы механизм множественной диспетчеризации работать уже не будет (вместо этого возникнет рекурсия).

Второй, и более весомой, причиной является то, что попытка создать ссылку на строку матрицы (@view A[i, :]) привела бы к тому, что компилятор Julia сгенерировал бы не слишком эффективный код. Это произошло бы по той причине, что в языке Julia, следуя традиции языка Fortran,  матрицы размещаются в памяти по столбцам, а не по строкам (как это имеет место в таких языках, как C/С++, Python). Последнее означает, что ссылка на строку не была бы ссылкой на непрерывную область памяти, что и привело бы к указанной проблеме.

## Cортировка вектора по значению заданной функции

Иногда требуется сортировать вектор не по значениям его элементов, а по значениям некоторой функции от его элементов. Например, может понадобиться отсортировать вектор по значениям абсолютных величин его элементов. Для этого встроенные функции sort!, sort, sortperm!, sortperm имеют именованный параметр (функционального типа), по умолчанию имеющий значение identity (identity - это встроенная функци одного аргумента, возвращающая просто значение своего аргумента).

Таким образом, если не изменить значение именнованного параметра на другое, сотрироваться массив будет, как мы ранее и предполагали, просто по значениям элементов. Но если, например, потребуется отсортировать некоторый массив A по значениям абсолютных величин его элементов, то с помощью встроенной функции sort! это следовало бы сделать так:

```julia
sort!(A, by=abs)
```

**Задача.** Добавить во все ранее написанные функции сортировки такой именованный параметр by.

## Сортировка столбцов матрицы по ключу

Ключем будем называть любую вещественно-значную функцию, определенную на строках матрицы. Например, в качестве ключа можно было бы использовать сумму элементов столбца, или сумму квадратов его элементов, или максимальное (минимальное) значение его элементов, число нулевых элементов в столбце и т.п.

Ключ удобно задавать в виде вектора значений ключевых значений столбцов. Каждый элемент такого вектора должен быть равен ключеввому значению соответствующего столбца. Например, если требуется отсортировать столбцы матрицы по значениям их сумм, то должен быть задан вектор, содержащий эти суммы. Тогда такой вектор можно отсортировать, например, с помощью встроенной функции sortperm!, а затем уже перставить столбцы заданной матрицы в соответствии с полученным векторм перестановок индексов столбцов.

**Задача.** Написать функцию, осуществляющую сортировку столбцов матрицы по произвольно заданному значению ключа.

**Решение.**

```julia
sortkey!(A::AbstractMarix, key_values) = A[:, sortperm!(key_values)]
```

Например, теперь переставить столбцы некоторой матрицы A в порядке неубывания их сумм можно так

```julia
sortkey!(A, sum(A, dim=1))
```

где значение именованного параметра dim = 1 встроенной функции sum указывает на то, что функция sum сформирует вектор, составленный из сумм столбцов матрицы A (т.е. - что суммурование должно осуществляется вдоль первой размерности матрицы).

## Сортировка методом подсчета (сортировка за линейное время)

В случае, если значения элементов сортируемого массива (A), являются элементами некоторого заранее известного относительно небольшого множества (values), то отсортировать такой массив можно за $O(n)$ операций следующим образом. Будем считать, что множество значений values представлено одноименным отсортированным массивом или диапазоном (тут вжно только, чтобы выполнялось условие values[i] < values[i+1]).

Сначала надо перебрать все элементы в массиве A и подсчитать, сколько раз встретилось каждое значение из данного набора значений values, а затем остается только в мвссив a поместить значение values[1] подсчитанное число раз, затем - values[2], и т.д., и, наконец, - values[end].

```julia
function calcsort!(a, values)
    num_val = zeros(Int, size(values))
    for v in a
        num_val[indexvalue(v,values)] += 1
    end
    k=1
    for i in eachindex(values)
        for j in 1:num_val[i]
            a[k] = values[i]
            k+=1
        end
    end
    return a
end
```

Здесь вспомогательная функция indexvalue(v, values) возвращает индекс значения v в наборе значений values. Реализация этой функции зависит от способа представления набора значений values.

В случае, если values - это диапазон целых чисел, то возможна следующая реализация.

```julia
indexvalue(v, values::UnionRange) = v - values[1] + 1
```

В случае, если values - это отсортированный вектор значений, то возможна также следующая реализация.

```julia
indexvalue(v, values::Vector) = findfirst(v, values)
```

**Замечание.** Если массив А является целочисленным, то множество всехвозможных значений элементов этого массива содержится в диапазоне minimum(A):maximum(A). Поэтому функция, реализующая сортировку целочисленного массива методом подсчета (что возможно, если только этот диапазон не является чрезмерно большим) может не иметь второго парметра. А именно

```julia
function calcsort!(A::Vector{<:Integer})
    min_val, max_val = extrema(A)
    num_val = zeros(Int, max_val-min_val+1) # если не указать здесь тип Int, то в дальнейшем это привело бы к ошибке (индексы должны быть целыми)
    for val in A
        num_val[val-min_val+1] += 1
    end  
    k = 0
    for (i, num) in enumerate(num_val)
        A[k+1:k+num] = min_val+i-1
        k += num
    end
end
```

Здесь была использована встроенная функция extrema, возвращающая два экстремальных значения массива.

# Практическое занятие 2

1. Реализовать все алгоритмы, обсуждавшиеся в лекции 1.
?????
2. Реализовать встроенную функцию reverse!, "переворачивающую" массив.
3. Написать функцию, осуществляющую сдвиг элементов **числового** массива на одну позицию вправо, заменяя освободившуюся позицию **нулем**.
4. Написать две функции, осуществляющую циклический сдвиг элементов массива на одну позицию вправо и влево, соответственно (функции удобно будет назвать circhift_right!(a), circhift_left!(a)).

**Замечание.** В случае циклического сдвига уже не обязательно предполагать массив числовым (поскольку не потребуется в него записывать число нуль).

**Решение.**

```julia
function circhift_right!(a)
    buf = a[end]
    for i in lastindex(a):-1:firstindex(a)-1
        a[i] = a[i-1]
    end
    a[begin] = buf
end

function circhift_left!(a)
    buf = a[begin]
    for i in firstindex(a):lastindex(a)-1
        a[i] = a[i+1]
    end
    a[begin] = buf
end
```

5. Написать функцию, осуществляющую циклический сдвиг элементов массива на `K` позиций, обеспечивающую сложность $O(N)$: если `K > 0`, то - вправо, если `K < 0`, то - влево. При этом вспомогательный массив не использовать.

**Замечание 1.** Имеются встроенные функции `circshift!`, `circshift`, решающие данную задачу.

**Замечание 2.** Если искомый алгоритм свести к повторному вызову `K` раз функции, осуществляющей сдвиг всего массива на одну позицию, то оценка сложности такого алгоритма была бы $O(N^2)$ (если предполагать, что диапазон возможных значений `|K|` есть `1:N-1`).

**Решение 1.**

```julia
????
```

**Решение 2.**  Для осуществления циклического сдвига элементов массива на `k` позиций также можно было бы воспользоваться следующей идеей.

Пусть, например, `k > 0`, тогда требуемый результат будет получен, если в массиве сначала перевернуть задом на перед каждую из двух его частей: с `1`-го по `k`-ый элемент, и с `k+1`-го по последний элемент, а затем перевернуть уже весь массив целиком еще раз.

```julia
function _circshift!(a, k)
    if k > 0
        reverse!(@view(a[1:k]))
        reverse!(@view(a[k+1:end]))
        reverse!(a) 
    elseif k < 0
        reverse!(a)
        reverse!(@view(a[1:-k]))
        reverse!(@view(a[-k+1:end]))
    end
    return a
end
```

1. Реализовать встроенные функции `isperm`, `permute!`, `invpermute!` (сложности $O(N)$ и не используюя вспомогательного массива)

Для реализации функции `isperm` (проверяющую, представляет ли заданный вектор целых чисел некотрую перестановку чисел `1,2,...,N`, или нет) достаточно проверить, во-первых, что, все его элементы принадлежат диапазону `1:N` (`N` - длина заданного вектора), и, во-вторых, что все содержащиеся в нем числа различны.

**Указание.** Постараться самостоятельно реализовать функцию `isperm`, а затем сравнить свой код, с кодом разработчиков Julia, который имеет следующий вид.

```julia
function _isperm(p)
    n = length(p)
    used = falses(n) # возвращает нулевой BitVector длины n
    for i in p
        (i in 1:n) && (used[i] ⊻= true) || return false # значек ⊻ - обозначает "исключающее или"
    end
    true
end
```
  
Функция invpermute!, выполняющая обратную перестановку, реализуется проще чем, функция permute!, выполняющая заданную перестановку индексов p, которая соответствовала бы срезу массива A[p].

```julia
function _invpermute!(A, p)
    for i in p
        if i > 0
            A[i], A[p[i]] = A[p[i]], A[i]
            p[i] = -p[i]
        end
    end
    for i in eachindex(p)
        p[i] = -p[i]
    end
    return A   
end
```

**Указание.** При реализации функции permute! воспользоваться тем фактом, что любая перестановка индексов представляет собой совокупность циклических перестановок некоторого числа непересекающихся наборов индексов.

```julia
function _permute!(A, p) 
    for i in eachindex(p)
        if p[i] < 0
            continue
        end 
        # i - начало очередной циклической перестановки индексов массива A            
        buff = A[i]
        j_prew, j = i, p[i] # - индекс элемента исходного массива, который требуется переместить на i-ю позицию                  
        p[i] = -p[i]
        while j != i # - пока циклическая перестановка индексов не "замкнулась"               
            A[j_prew] = A[j]
            j_prew, j = j, p[j]            
            p[j_prew] = -p[j_prew]
        end        
        A[j_prew] = buff 
        # перемещения элементов массива A по очередному циклу (по очередной циклической перестановке индексов) полностью завершены
    end
    for i in eachindex(p)
        p[i] = -p[i]
    end        
    return A
end
```

**Замечание.** Возможна также следующая реализация функции permute!

```julia
function __permute!(A, p) 
    inv_p = similar(p)
    inv_p[p] .= 1:length(p) 
    _invpermute!(A, inv_p)
end
```

Однако эта реализация потребовала создания вспомогательного массива, для размещения обратной перестановки индексов inv_p.

# Практическое занятие 3

1. Реализовать алгоритм сортировки "расчесыванием"

# Практическое занятие 4

1. Реализовать алгоритм сортировки Хоара
2. Реализовать вычисление k-ой порядковой статистики методом Хоара (обеспечить сложность алгоритма O(n))
3. Реализовать вычисление медианы массива (основываясь на алгоитрме вычислениия порядеовых статистик)
4. Реализовать поиск первых k наименьших элементов массива (k - фиксированное значение, от длины массива не зависящее). Обеспечить сложность O(n), не используя процедуру Хоара.
5. Реализовать однопроходный алгоритм вычисления среднего квадратического отклонения от среднего значения массива


# Практика 5+

1. Расширенный алгоритм Евклида
2. Обращение обратимых элементов кольца вычетов
3. Приближенное решение уравнений методом деления отрезка пополам

```julia
function bisec(f::Function, a, b; atool = 1e-15)
    @assert f(a)*f(b) < 0
    # Инвариант: f(a)*f(b) < 0
    while b-a > atool
        x = (a+b)/2
        f_a = f(a)
        if f_a == 0
            return x
        elseif f_a * f(x) > 0
            a = x
        else
            b = x
        end
    end
    return x
end
```

4. Реализовать встроенную функцию isprime(n), O(log(n))

```julia
function isprime_(n::T)::Bool where T <: Integer
    for i in 2:round(T, sqrt(n))
        if n % i == 0
            return false
        end
    end
    return true
end
```

5. Реализовать алгоритм "решето Эратосфена", вычисляющий все простые числа, не превосходящие заданного натурального числа

```julia
function eratosphen(n::Integer)::BitVector
    is_prime = ones(Bool, n) 
    is_prime[1] = false # 1 — не является простым числом
    for i in 2:round(Int, sqrt(n))
        if is_prime[i] 
            for j in (i*i):i:n 
                is_prime[j] = false
            end
        end
    end
    return (1:n)[is_prime] # filter(x -> is_prime[x], 1:n) 
end
```

6. Простые делители числа и их кратности

# Практическое занятие 6
  
## Приближенное решение уравнений методом Ньютона

Рассмотрим уранение вида

$$ f(x)=0 $$

где $f: [a;b] \to \mathbb{R}$ - некоторая, вообще говоря, не линейная функция.

Ранее такого рода уравнения мы решали методом деления отрезка пополам. Рассмотрим теперь ещё один метод, называемый методом Ньютона или методом касательных.

Согласно методу Ньютона получить приближенное решение рассматриваемого уравнения можно, воспользовавшись следующей рекуррентной формулой:

$$ x_{n+1}=x_n-\frac{f(x_n)}{f^\prime(x_n)} $$

где $n=0,1,2,3,..., \ \ \ x_0$ - заданное начальное приближение.

Вычисления по этой формуле следует прекращать при  достижении условия:

$$ |x_{n+1}-x_n|\le \varepsilon $$

где  $\varepsilon>0$ - заданная величина, определяющая погрешность вычислений.

Кроме того, при неудачном выборе начального приближения $x_0$ вычисляемая последовательность $x_n$ может не иметь предела (не сходиться к искомому корню).

Поэтому, чтобы избежать возможных зацикливаний, число итераций метода должно быть ограничено некоторой величиной (обычно не слишком большой).

## Вывод формулы метода Ньютона

Пусть $x_0$ - это некотрое начальное приближение неизвестного нам точного решения $x^*$ рассматриваемого уравнения ($f(x^*)=0$). И пусть функция $f(x)$ дважды дифференцируемая в некоторой окрестности своего корня, включающей точу $x_0$. Тогда, положив $\Delta=x^*-x_0$, и воспользовавшись формулой Тейлора для малой окрестности точки $x_0$, можем записать:

$$ f(x_0+\Delta)=f(x_0)+f^\prime(x_0)\Delta+o(\Delta) $$

Откуда, т.к. $x_0+\Delta=x^*$, имеем нелинейное уравнение:

$$ f(x^*)=f(x_0)+f^\prime(x_0)(x^*-x_0)+o(\Delta) = 0 $$

Если отбросить $o(\Delta)$, то это нелинейное уранение будет заменено линейным (относительно переменной, которую мы теперь обозначим $x_1$):

$$ f(x_0)+f^\prime(x_0)(x_1-x_0) = 0 $$

Решая это линейное уранение, получим формулу:

$$ x_1=x_0-\frac{f(x_0)}{f^\prime(x_0)} $$

Если при этом значение $x_1$ оказалось ещё ближе к искомому корню чем $x_0$, то процедуру можно повторить. Таким образом, приходим к следующей схеме вычислений: 

$$ x_{n+1}=x_n-\frac{f(x_n)}{f^\prime(x_n)} $$

где $n=0,1,2,3,...$.

**Замечание.** Метод Ньютона можно проиллюстрировать [геометрически](https://ru.wikipedia.org/wiki/Метод_Ньютона#Геометрическая_интерпретация). Это объесняет причину, по которой данный метод называют ещё методом касательных.

Полученную ранее рекуррентную формулу также лего получить и из чисто геометрических соображений.

## Обобщение метода Ньютона на случай комплексной переменной

Рассмотрим уравнение $f(z)=0$, где $f: \mathbb{C} \to \mathbb{C}$, - некоторая дифференциируемая функция комплесного переменного.

Определение производной в случае комплексной переменной внешне вполне совпадает с таковым для функции вещественной переменной:

$$ f'(z) = \lim_{\abs{\Delta z} \to 0} \frac{f(z+\Delta z)-f(z)}{\Delta z} $$

Из этого, в частности, следует, что $(z^n)'=nz^{n-1}$. Таким образом, многочлены, как функции комплексной переменной, можно дифферецировать по привычным правилам.

В результате оказывается, что полученная ранее рекуррентная формула применима в неизменном виде и в случае дифференцируемой функции комплексной переменной.

Ввиду сказанного, метод Ньютона можно использовать, например, для поиска комплексных кореней многочленов.

**Замечание.** Для вычисления корней уравнений для Julia имеется специальный пакет [Roots.jl]](https://docs.juliahub.com/Roots/o0Xsi/1.0.8/).

## Задания для программирования

1. Написать функцию, реализующую метод Ньютона

**Описание функции:**

```julia
"""
function newton(r::Function, x_0; epsilon = 1e-8, max_num_iter = 20)

Ищет корень уравнения f(x)=0
-- r(x)= -f(x)/f'(x)
-- x_0 - начальное приближение
-- epsilon > 0 - пераметр, определяющий точность вычислений
(критерй останова: |x - x_prev| = |r(x_prev)| <= epsilon)
-- max_num_iter - максимальное число итераций
"""
```

**Решение:**

```julia
function newton(r::Function, x; epsilon = 1e-8, max_num_iter = 20)
    num_iter = 0
    r_x = r(x)
    while num_iter < max_num_iter && abs(r_x) > epsilon
        x += r_x
        r_x = r(x)
        num_iter += 1
    end

    if abs(r_x) <= epsilon
        return x
    else
        return NaN
    end
end
```

2. С помощью функции newton решить уравнение $cos(x)=x$

**Решение.**

```julia
# f(x) = cos(x)-x

# f'(x) = -sin(x)-1

# r(x) = -f(x)/f'(x) = (cos(x)-x)/(sin(x)+1)

newton(x -> (cos(x)-x)/(sin(x)+1), 0.5)
```

3. С помощью функции `newton` и написанной ранее функции `polyval`, возвращающей значение многочлена (заданного вектором коэффициентов) и его производной в заданной точке, написать функцию, возвращающее приближенное значение комплексого корня многочлена, ближайшего к заданной точке комплексой плоскости.

Алгоритм вычисления многочлена, заданного массивом коэффициентов, и его производной в произвольной точке был рассмотрен в [лекции 1](s2_lecture_1.md).

Соответствующая функция может быть реализована следующим образом.

```julia
"""

"""
function polyval(P,x)
    dQ = 0
    Q = P[1]
    for i in 2:length(P)
        dQ = dQ*x + Q
        Q = Q*x + P[i]
    end
    return Q, dQ
end
```

**Указание.** Фактический параметр функционального типа функции newton в данном случае может быть определён следующим образом.

```julia
# P - внешняя переменная, содержащая коэффициенты многочлена, следующих в порядке убывания степеней

function r(x)
    y, dy = polyval(P, x)
    return -y/dy
end
```

**Замечание.** Функция r(x) представляет собой замыкание внешней переменной P.

4. Написать функцию, по заданному начальному приближению вычисляющую приближенное значение корня уравнения $f(x)=0$ в случае, когда нет практической возможности получит выражение для $f'(x)$, и вместо этого приходится пользоваться приближенной формулой:

$$f'(x) \approx \frac{f(x+h)-f(x)}{h}$$

где, например, можно положить $h = 1e-8$.

**Замечание.** Если здесь взять значение $h$ слишком маленьким, например, равным 1e-15, то, вместо теоретически ожидаемого увеличения точности вычисления производной, это может привести, наоборот, к её катастрофическому уменьшению, что связанно с возможным наличием погрешностей в вычисляемых значениях самой функции).

5. Воспользовавшись результатами пункта 4, визуализировать так называемую проблему Кэлли, состоящую в следующем.

Как известно уравнение
$$ z^3 - 1 = 0 $$
имеет 3 комплексных корня.

Требуется раскрасить комплексную полоскость (некоторую ее квадратную часть, содержащую круг единичного радиуса, на котором лежат корни уравнения) на три части, каждая из которых есть "бассейн притяжения" одного из трех корней уравнения.

Для этого можно взять наугад какую-либо точку из заданного квадрата (содержащего единичный круг), итерировать с этим началным значением по методу Ньютона, и если найденное в результате итераций значение окажется в некоторой достаточно малой окрестности k-го корня уравнения (k=0,1,2), то данная начальная точка должна быть окрашена в соответствующий цвет.

Задача будет решена в результате многократного применения этой процедуры к случайно выборанной начальной точке.

Для построения графиков можно воспользоваться графическим пакетом [Plots.jl](https://docs.juliaplots.org/latest/tutorial/)

# Практика 7

(На самом деле это занятие надо было бы переставить местами с практикой 6)

Реализовать (и протестировать) типы Residue и Polynomial, обсуждавшиеся в [лекции 4](s2_lecture_4.md).

# Практика 8

# Вычисление частичной суммы степенного ряда, с использованием рекуррентной формулы

**Задача 1.** Известно, что

$$ e= \lim_{n \to \infty} \Big(\frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...+\frac{1}{n!} \Big) = \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...$$

Следующий программный код вычисляет n-ю частичную сумму этого ряда (сумму его первых n слагаемых):

```julia
# n - заданное число
sum_n = 0
for k in 0:n
    sum_n += 1/factorial(k)
end
```

Требуется дать асимптотическую оценку алгоритмической сложности этого алгоритма (в зависимости от числа n).

Оценка алгоритмической сложности функции factorial(k) есть $O(k)$. Поэтому общая оценка алгоритмической сложности всего алгоритма получается $O(n^2)$, поскольку $1+2+...+n=n(n+1)/2$.

Однако ту же самую частичную сумму можно вычислять так, чтобы оценка сложности была $O(n)$. В самом деле, вычисляя factorial(k), мы никак не использовали то, что на предыдущем шаге было вычислено factorial(k-1), что приводит к повторным вычислениям.

Чтобы избавиться от повторных вычислений, тут надо воспользоваться рекуррентным соотношением:

$$ f_k=f_{k-1}\cdot k, $$

где $f_k=k!$, при начальном значении $f_0=1$.

Или, что еще лучще,
$$ a_k=a_{k-1}/k, $$
где $a_k=\frac{1}{k!}$, при начальном значении $a_0=1$, поскольку на каждой итерации это будет экономить ещё одну арифметическую операцию (деления).

Таким образом, имеем эффективное решение

```julia
# n - заданное число
s = 0.0
a = 1.0
for k in 1:n+1 
# границы значений индекса k по отношению к прежнему варианту теперь смещены на 1 вправо
    s += a
    a /= k
end
```

Это процедура с оценкой сложности $O(n)$.

**Вопрос.** При n > 20, выполнение следующего кода приведет к ошибке (OverflowError - ошибка переполнения переменной).

```julia
sum_n = 0.0
for k in 0:n
    sum_n += 1/factorial(k)
end
```

Почему при том же условии (n > 20) выполнение следующего кода к этой ошибке уже не приводит?

```julia
# n - заданное число
s = 0.0
a = 1.0
for k in 1:n+1 
# границы значений индекса k по отношению к прежнему варианту теперь смещены на 1 вправо
    s += a
    a /= k
end
```

**Задача 2.** Выполнить следуюшие пункты.

- Оформить предыдущий алгоритм в виде функции с заголовком: eyler(n), где параметр n \- это число слагаемых частичной суммы.
- Экспериментально убедиться, что начиная с некоторого достаточного большого значения n результат вычислений перестаёт изменяться.  Требуется дать этому факту объяснение, исходя из свойств арифметики с плавающей точкой.

- Объяснить, что получится в результате выполнения следующей функции, и почему при её выполнении не будет происходить зацикливания.

```julia
function eyler()
    s = 0
    a = 1
    k = 0
    while s + a != s
        k += 1
        s += a
        a /= k
    end
    return s
end
```

**Замечание 1.** Объяснение состоит в том, что при вычислении `s+a` должны будут складываться соответствующие 53-х битные мантиссы (здесь речь идет о формате типа Float64). Но сначала порядок меньшего слагаемого должен быть приведен к порядку большего слагаемого путем "сдвига" его мантиссы вправо с заменой "освобождающихся" битов нулями. Таким образом, если сдвиг составит 53 бита или больше, то мантисса меньшего числа окажется полностью замененной нулями.

**Замечание 2.** Путем сохранения значения sum_n + a_n в дополнительной переменной уменьшить число оперераций сложения в цикле на 1.
  
## Суммирование сходящегося ряда с заданной точностью

Пусть требуется просуммировать сходящийся бесконечный ряд

$$ s= \lim_{n \to \infty} \Big(a_1+a_2+...+a_n \Big) =a_1+a_2+...+a_k+... $$

с наперед заданной точностью $\varepsilon > 0$, т.е. подобрать такое число $n$, чтобы

$$ |s-s_n|\le \varepsilon $$

где

$$ s_n=a_1+...+a_n $$

\- это $n$-я частичная сумма ряда, а

$$ s=\lim_{n \to \infty}s_n $$

\- это сумма ряда.

Здесь нам понадобится следующий факт из математического анализа (с которым в скором времени вы познакомитесь в курсе математического анализа).

Числовой ряд называется знакопеременным, если

$$ \forall k \ a_k \cdot a_{k+1}<0 $$

**Теорема** (признак Лейбцица сходимости знакопеременного ряда).

Пусть имеется знакопеременный числовой ряд

$$ a_1+...+a_k+... $$

тогда данный ряд сходится, если выполнены следующие два условия

- $a_k \to 0, \ k \to \infty$

- стремление к нулю $k$-го члена ряда является монотонным, т.е. $|a_k|<|a_{k+1}|$ (по крайней мере начиная с некотрого $k_0$, т.е. для $k\ge k_0$);

при этом (что для нас особенно важно)

$$ |s-s_n|\le |a_{n+1}| $$

т.е. величина погрешности, с которой $n$-я частичная сумма апроксимирует искомую сумму ряда, не превосходит величины первого "отбрасываемого" члена ряда (знакочередующегося).

Таким образом, чтобы просуммировать знакочередующийся ряд с заданной точностью, достаточно прекратить суммирование (прервать соответствующий цикл) при выполнении условия $|a_k|<=\varepsilon$.

**Замечание.** Рассматриваемая величина $\varepsilon$ определяет оценку **абсолютную погрешность** $\Delta s = |s-s_n|$ искомой величины $s$. Наряду с абсолютной погрешность в вычислениях важное значение играет понятие **относительной погрешности** $\delta s = \Delta s / |s|$ (предполагается, что $s \ne 0$).

**Задача 3.** Известно, что функция $\sin(x)$ в окрестности нуля представляется своим рядом Тейлора

$$ \sin(x)=\frac{x}{1!}-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+... $$

Этот ряд сходится при всех $x$ и является знакочередующимся.

Требуется написать функцию, вычисляющую по этой формуле значение $\sin(x)$ для заданного $x$ с заданной максимально допустимой погрешностью $\varepsilon>0$.

**Замечание.** Если фиксировать значение перемнной $x$, то расматриваемый степенной ряд есть просто числовой ряд, и, следовательно, к нему можно применить теорему Лейбница о сходимости знакочередующегося числового ряда.

**Указание.** Для построения эффективного алгоритма, вычисляющего частичные суммы рассматриваемого ряда, сначала получить рекуррентную формулу для вычисления k-члена этого ряда.

Имеем

$$ a_k=(-1)^{k-1}\frac{x^{2k-1}}{(2k-1)!} $$

где $k=1,2,3,...$.

Тогда

$$ \frac{a_{k+1}}{a_k}=\frac{(-1)^{k}\frac{x^{2k+1}}{(2k+1)!}}{(-1)^{k-1}\frac{x^{2k-1}}{(2k-1)!}}=-\frac{x^2}{2k(2k+1)} $$

Откуда уже получаем искомую рекуррентную формулу:

$$ a_{k+1}=-a_k\cdot \frac{x^2}{2k(2k+1)} $$

Основываясь на найденной формуле, можно уже написать требуемую функцию.

```julia
function Base.sin(x,ε)
    xx=x^2
    a=x
    k=1
    s=typeof(x)(0) # - преобразование к 0 нужного типа, что обеспечит стабильность типа переменной s
    while abs(a)>ε
        s+=a
        a=-a*xx/2k/(2k+1)
        k+=1
    end
    #УТВ: |sin(x)-s|<= ε
    return s
end
```

Код этой функции можно ещё немного оптимизировать, т.е. уменьшить число арифметических операций, выполняемых на каждой итерации, если заметить, что последовательность значений $2k$ ($k=1,2,3,...$) представляет собой последовательность четных чисел, которую можно получать на основе рекуррентного соотношения:

$$ m_{k+1}=m_k+2 $$

где $m_k=2k$, при начальном условии $m_1=2$. Т.е.

```julia
function Base.sin(x,ε)
    xx=x^2
    a=x
    m=2
    s=typeof(x)(0) 
    while abs(a)>ε
        s+=a
        a=-a*xx/m/(m+1)
        m+=2
    end
    #УТВ: |sin(x)-s|<= ε
    return s
end
```

**Вопрос**: что получится, если в этом цикле условие $|a|>ε$ заменить условием $s+a \ \ \ != s$?

**Замечание.** Следующие варианты ответа являются не верными:

- "произойдет зацикливание, поскольку равенство невозможно, в виду того, что всегда `a>0`;

- величина `a` от итерации к итерации постоянно уменьшается, поэтому цикл завершится, как только её значение достигнет значение машинного нуля (для Float64 равного приблизительно `1e-324`).

**Правильный ответ**: цикл завершится, как только разность двоитчных порядков величин `s` и `a` достигнет `53` (что примерно соответствует шестнадцати десятичный порядков).

С учетом сказанного, функция, вычисляющая значение sin(x) можем быть запрограммирована следующим образом.

```julia
function sin_(x) 
    xx=x^2
    a=x
    m=2
    s=typeof(x)(0) 
    while s+a != s
        s+=a
        a=-a*xx/m/(m+1)
        m+=2
    end
    #УТВ: |sin(x)-s| <= 1е-16
    return s
end
```

**Задача 4.** Воспользовавшись известным разложением

$$ \exp(x) = 1 + x + \frac{x^2}{2!}+...+\frac{x^k}{k!}+...$$

написать функцию `exp_(x)`, вычисляющую значение `exp(x)`.

**Экспериментально убедиться**, что, например, exp_(-20) даст значение, в мантиссе которого не будет ни одной верной цифры, в то время как верное значение можно будет получить, вычислив 1/exp_(20) (для контроля результатов вычислений следует использовать встроенную функцию exp(x), котрорая выдает адекватный результат для любого своего аргумента).

**Замечаниею** Объяснение указанного факта состоит в следующем.
Если аргумент функции `exp_(-20)` меньше нуля, то при её вычислении суммируется **знакопеременный** ряд, причем значение искомой суммы ряда - есть величина близкая к нулю (порядка 1e-9).

Таким образом, во-первых, при этих вычислениях неизбежно придется из одного маленького числа вычитать другое, тоже маленькое, примерно того же порядка. И это будет приводить к потере точности, связанной с тем, что при вычитанни одной мантиссы из другой в очень многих старщих разрядах будут получаться нули, и это будет означать укорочение мантиссы результата вычитания (т.е. потерю точности).

При этом относительная погрешность результата будет возрастать ещё сильнее (см. определение относительной погрешности, приведенное выше).

**Задача 5.** Проанализировать следующую ситуацию, предварительно проведя соответствующие численные эксперименты.

Известно, что

$$ \lim_{n \to \infty} \Big(1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+... + \frac{1}{n} \Big)=\infty$$

т.е. что числовой ряд

$$ 1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+... $$

расходится (этот расходящийся ряд называется **гармоническим**).

Можно написать функцию, "вычисляющую сумму" этого (расходящегося!) ряда, воспользовавшись прежним приёмом численного суммирования.

```julia
function harmonic_sum()
    s=0.0
    k=1
    a=1.0
    while s+a != s
        a=1/k
        s+=a 
        k+=1
    end
    return s
end
```

Теоретически данный цикл будет завершен, как только разность двоичных порядков величин `s` и `a` достигнет `53`. Когда-нибудь это должно будет произойти, поскольку величина `s` от итерации к итерации монотонно возрастает, а величина `a` монотонно убывает. Однако на практике дождаться этого события врядли получится, поскольку и то и другое будет происходить довольно медленно.

**Задача 6**. Написать функцию, вычисляющую $n$-ую частичную сумму ряда Тейлора функции

$$\cos(x)=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+...$$

для заданного значения аргумента $x$. Вычислительная сложность алгоритма должна иметь оценку $O(n)$.

**Задача 7**. Написать функцию, вычисляющую значение суммы ряда Тейлора функции $\cos(x)$ в заданной точке с машинной точностью.

**Указание**. Постараться минимизировать число арифметических операций.

Протестировать функцию, путем сравнения получаемых результатов с результатами, выдаваемыми встроенной функцией $\cos(x)$.

**Задача 8**. Построить семейство графиков $n$-ых частичных сумм ряда Тейлора функции $\cos(x)$ на одном её периоде, для $n=2,4,8,16$.

**Указание.** Допустим имеется функция `part_sum(n,x)`, возвращающая значение n-ой частичной суммы в точке х. Чтобы построить её график на интервале от 0 до 10, например, для n=4, средствами Julia достаточно будет написать следующий код.

```julia
using Plots

x = 0:0.1:10
plot(x, part_sum.(4,x))
```

А чтобы постоить семейство графиков, например, для n=2,4,6,8, достатчно заменить последнюю строчку приведенного кода на следующий код.

```julia
p = plot() # получена ссылка на пустой график
for n in 2:2:8
    plot!(p, x, part_sum(n,x)) # в текущий график добавлена новая кривая
end
display(p) # график, содержащий семейство кривых, отображен
```

**Задача 9**. Получить рекуррентные соотношения, требуемые для суммирования без повторных вычислений следующих степенных рядов

$$
1)\ \ln(x)=\sum_{k=0}^\infty(-1)^k\frac{(x-1)^{k+1}}{k+1}, \ \ \ 0 < x < 1
$$
(**указание:** положить $a_k=(-1)^k(x-1)^{k+1}/(k+1)=b_k/(k+1)$, где $b_k=-(1-x)^{k+1}$ и для вычисления последовательности $b_k$ получить  рекуррентную формулу);
$$
2)\ \frac{1}{\sqrt{1+x}}=1+\sum_{k=1}^{\infty}(-1)^k\frac{1\cdot3\cdot5\cdot...\cdot (2k-1)}{2\cdot4\cdot6...\cdot(2k)}x^k
$$
(**указание:** для вычисления последовательности $a_k=(-1)^k\frac{1\cdot3\cdot5\cdot...\cdot (2k-1)}{2\cdot4\cdot6...\cdot(2k)}x^k$ получить рекуррентную формулу);
$$
3)\ x\sin x - \exp(-x^2)+1=\sum_{k=1}^{\infty}(-1)^{k+1}\Big(\frac{1}{k!}+\frac{1}{(2k-1)!}\Big)x^{2k}
$$
(**указание:** положить $(-1)^{k+1}\Big(\frac{1}{k!}+\frac{1}{(2k-1)!}\Big)x^{2k}=u_k(v_k+w_k)$, где $u_k=(-1)^{k+1}x^{2k},\ v_k=1/k!, w_k=1/(2k-1)!$ и последователности $u_k,v_k,w_k$ вычислять по соответствующим рекуррентным формулам).

Для контроля правильности просуммировать эти ряды с машинной точностью в точке $x=0.5$, и полученные результаты сравнить со значениями соответствующих функций (указанных в левых частях равенств).

**Задача 10**. Следующий степенной ряд определяет семейство так называемых функций Бесселя 1-го рода порядка $m$ ($m=0,1,2,...$)
$$
J_m(x)=\Big(\frac{x}{2}\Big)^m\sum_{k=0}^{\infty}\frac{(-1)^k}{k!(k+m)!}\Big(\frac{x}{2}\Big)^{2k}
$$
Написать функцию `besselj(m,x)`, вычисляющую функцию Бесселя 1-го рода порядка $m$ в точке $x \in \mathbb{R}$ с машинной точностью, и построить семейство графиков для $m=0,1,2,3,4,5$
(вид требуемых графиков см., например, [здесь](https://ru.wikipedia.org/wiki/Функции_Бесселя)).

**Замечание.**  Определение функции besselj(m,x) имеется также  в пакете [SpecialFunctions.jl](https://juliamath.github.io/SpecialFunctions.jl/stable/), который требует предварительной установки.

# Практика 9

**Задача 1.** Написать функцию, реализующую "обратный ход" метода Гаусса, т.е. функцию, получающую на вход верхне-треугольную матрицу и вектор-столбец свободных членов, и возвращающую вектор-столбец решения соответствующей СЛАУ.

**Указание.** Решение задчи сводится к вычислениям по формуле:

$$
x[N-k] = \big(b[n-k]-A[n-k,n-k+1]x[N-k+1]-...-A[N-k,N]x[N]\big)/A[N-k,N-k]
$$
где $N$ - размер матрицы (квадратной), $k \in 0:N-1$.

Возможный вариант кода:

```julia
function reverse_gauss_1(A,b)
    x = similar(b)
    N = size(A, 1)
    for k in 0:N-1
        x[N-k] = (b[N-k] - sum(@view(A[N-k,N-k+1:N]) .* @view(x[N-k+1:N])))/A[N-k,N-k]
    end
    return x
end 
```

Оптимизированный вариант:

```julia
using LinearAlgebra

function reverse_gauss(Ab)
#Ab - транспонированная расширенная матрица 
    N = size(A, 2)
    x = Vector{eltype(Ab)}(undef,N)
   
    for k in 0:N-1
        x[N-k] = (Ab[N-k, N] - dot(@view(Ab[N-k+1:N, N-k]), @view(x[N-k+1:N])))/Ab[N-k,N-k]
    end
    return x
end 
```

Требуется с помощью макроса @time провести временные замеры для сравнения этих двух вариантов.
**Внимание.** Для получения  правильного результата ккаждая функция должна вызываться минимум дважду (время первого вызова будет включать также и время компиляции).

**Как формировать исходные данные для тестирования?**

Сформировать случайную верхнетреугольную матрицу можно следующим образом.

Имеет место
**Теорема** (о LU разложении). Любая невырожденная матрица A может быть представлена произведением матриц L и U, где L - нижнетреугольная матрица, U - верхнетреугольная матрица.

В пакете LinearAlgebra (он установлен в julia изначально) имеется функции lu, которая выполняет такое разложение входной матрицы.

С помощью этой функции можно генерировать случайную верхнетреугольную матрицу требуемого размера следующим образом.

```julia
using LinearAlgebra

function upper_triangular(N::Integer)
    A = randn(N)
    _, A = lu(A)
    return A
end
```

**Замечание.** Следующий код тоже будет генерировать случайные верхнетреугольные матрицы, однако эти матрицы могут оказаться чрезвычайно плохообусловленными. Такие матрицы не подходят для тестирования.

```julia
function upper_triangular(N::Integer)
    A = zeros(N,N)
    for i in 1:N
        A[i,i+1:N] = randn(N-i)
        A[i,i] = 1.0
    end
    return A
end
```

**Задача 2.** Написать функцию, реализующую приведение расширенной матрицы СЛАУ к ступенчатому виду.

**Указание.** При разработке алгоритма соблюсти следующие пункты:

- Должен осуществляться выбор ведущего элемента в столбце (для для этого можно использовать встроенную функцию высшего порядка `findmax`).

- Найденный ведущий элемент нужно проверить на "равенство" нулю, точнее говоря сравнить его абсолютную величину со значением, скажем, `1e-8`...`1e-6` - если она не превосходит этой величины, то матрицу нужно считать вырожденной. В этом случае нужно сгененровать исключительную ситуации с помощью встроенной функции `throw("Матрица СЛАУ вырождена")`.

- Поскольку в языке Julia матрица размещается в памяти по столбцам, то работать следует с транспонированной расширенной матрицей.

#---------------------------------------------------------------

function add_1(A::AbstractMatrix{T}, B::AbstractMatrix{T}) where T<:Number
    @assert size(A) == size(B)
    C = similar(A)
    for i in 1:size(A,1), j in 1:size(A,2) # 
        C[i,j] = A[i,j] + B[i,j]
    end
    #= это эквивалентно:
    for i in 1:size(A,1)
        for j in 1:size(A,2)
            C[i,j] = A[i,j] + B[i,j]
        end
    end
    =#
    return C
end

function add_2(A::AbstractMatrix{T}, B::AbstractMatrix{T}) where T<:Number
    @assert size(A) == size(B)
    C = similar(A)
    for  j in 1:size(A,2), i in 1:size(A,1) # - это более педпочтиельный вариант (преимущество проявляется на больших матрицах)
        C[i,j] = A[i,j] + B[i,j]
    end
    return C
end
 
using LinearAlgebra

function mul(A::AbstractMatrix{T}, B::AbstractMatrix{T}) where T<:Number 
    @assert size(A,2) == size(B, 1)
    C = Matrix{T}(undef, size(A,1), size(B,2))
    At=A'
    for j in 1:size(C,2), i in 1:size(C,1)
        p=0.0
        for k in 1:size(A,2) # size(A,2) == size(B, 1)
            p += At[k,i]*B[k,j]
        end
        C[i,j] = p
    end
    return C
end

function mul_1(A::AbstractMatrix{T}, B::AbstractMatrix{T}) where T<:Number 
    @assert size(A,2) == size(B, 1)
    C = Matrix{T}(undef, size(A,1), size(B,2))
    for i in 1:size(C,1), j in 1:size(C,2)
        @views C[i,j] = dot(A[i,:],B[:,j])
    end
    #= это эквивалентно:
    for i in 1:size(C,1), j in 1:size(C,2)
        C[i,j] = T(0)
        for k in 1:size(A,2) # size(A,2) == size(B, 1)
            C[i,j] += A[i,k]*conj(B[k,j])
        end
    end
    =#
    return C
end

function mul_2(A::AbstractMatrix{T}, B::AbstractMatrix{T}) where T<:Number
    @assert size(A,2) == size(B, 1)
    C = Matrix{T}(undef, size(A,1), size(B,2))
    for j in 1:size(C,2), i in 1:size(C,1)
        @views C[i,j] = dot(A[i,:], B[:,j])
    end
    return C
end

function mul_3(A::AbstractMatrix{T}, B::AbstractMatrix{T}) where T<:Number
    @assert size(A,2) == size(B, 1)
    C = Matrix{T}(undef, size(A,1), size(B,2))
    At = A'
    for j in 1:size(C,2), i in 1:size(C,1)
        @views C[i,j] = dot(At[:,i], B[:,j])
    end
    return C
end


#----------------------------------------------------
print("N = ")
N = parse(Int, readline())
#=
При N=10_000 выигрыш примерно на порядок
при N=1000 он всего раза в два
=#
A = randn(N,N)
B = randn(N,N)
println("Варианты реализации сложения матриц:")
@time add_1(A,B);
@time add_2(A,B);
println("Варианты реализации перемножения матриц:")
@time mul(A,B);
#=
@time mul_1(A,B);
@time mul_2(A,B);
@time mul_3(A,B);
=#
println()

# Практика 10

1. Написать функцию, приводящую матрицу к ступенчатому виду с помощью элементарных преобразований строк

**Указание.** Реализовать выбор ведущих элементов столбцов (наибольших по абсолюной величине). Сравнение значения ведущего элемента с нулем осуществить с точностью до некоторой заданной величины epsilon (1e-7)

**Решение.**

```julia
function transform_to_steps!(A::AbstractMatrix; epsilon = 1e-7, degenerate_exeption = true)
   # @inbounds - заметного ускорения здесь это не даёт!!!
   for k ∈ 1:size(A, 1)
        absval, Δk = findmax(abs, @view(A[k:end,k]))
        (degenerate_exeption && absval <= epsilon) && throw("Вырожденая матрица")
        Δk > 1 && swap!(@view(A[k,k:end]), @view(A[k+Δk-1,k:end])) 
        for i ∈ k+1:size(A,1)
            t = A[i,k]/A[k,k]          
            @. @views A[i,k:end] = A[i,k:end] - t * A[k,k:end] 
            # макрос @. заменяет все "сквозные точки"
            # макрос @views заменяет многократное применение макроса @view
        end
    end
end
#=
Вместо:

    Δk > 1 && swap!(@view(A[k,k:end]), @view(A[k+Δk-1,k:end])) 
можно было бы так:
    if Δk > 1
        A[k,k:end], A[k+Δk-1,k:end] = A[k+Δk-1,k:end], A[k,k:end]
    end 
=#

function swap!(A,B)
    for i in eachindex(A)
        A[i], B[i] = B[i], A[i]
    end
end
```

2. Реализовать приведение матрицы к ступенчатому виду с помощью элементарных переобразований столбцов (соответствующую функцию можно назвать transform_to_steps_2!).

Провести временные замеры для этих двух алгоритмов на больших случайных матрицах.

Убедиться, что существенных отличий в скорости не будет.
**Вопрос:** как это объяснить, ведь матрицы в Julia размещаются в памяти по столбцам, и, казалось бы, исходя из этого, второй алгоритм должен бы иметь преимущество.

3. Доработать (изменить) функцию transform_to_steps! так, что бы она возвращала вектор, содержащий индексы тех столбцов приведенной к ступенчатому виду матрицы, в которых НЕ содержатся её "угловые" элементы (в порядке возрастания индексов этих столбцов); так, если матрица не вырожденная, то будет возвращен пустой вектор.

4. Используя доработанный вариант функции transform_to_steps!, написать функцию, возвращающую ранг матрицы, а также - функцию, возвращающую определитель матрицы.

**Указание.** Функции, возвращающие ранг или определитель матрицы, не должны "портить" (т.е. изменять) передаваемую им матрицу.

**Замечание.** В пакете LinearAlgebra имеется соответствующие функции rank и det (поэтому свои функцию лучше назвать иначе, например, rank_, det_).

5. Написать функцию, решающую СЛАУ вида Ax=b (матрица A пердполагается не вырожденной). Эта функция не должна "портить" передаваемые ей (по ссылке) внешние массивы A и b.

6. Написать функцию, получающую на вход матрицу A и вектор b, и возвращающую единственное решение СЛАУ Ax=b, в случе, если матрица A - не выроженная, или - пустой кортеж, если СЛАУ не совместна, или - двухэлементный кортеж из прямоугольной матрицы, столбцы которой содержат фундаментальную систему решений соответствующей однородной СЛАУ и из вектора с каким-либо частным решением исходной неоднородной СЛАУ, если эта система совместна, но её матрица вырожденная.

7. Используя функцию transform_to_steps!, напиать функцию, возвращающую обратную матрицу (матрица A пердполагается не вырожденной).

**Замечание.** В Julia имеется соответствующая встроенная функция inv (поэтому свою функцию лучше назвать иначе, например, inv_).

# Практика 11

При выполнении следующих заданий удобно будет использовать блокноты Jupyter (см. лекцию 6).

При этом рекомендуется программный код размещать в jl-файлах, а в ячейки блокнота вставлять содержащиеся в них определения функций с помощью include. После чего вызывать функции на исполнение можно будет уже из ячеек блокнота.

1. Написать функции, осуществляющие следующие действия.

- Поиск точки пересечения (если она существует) двух заданных отрезков на плоскости.

- Вычисление угла между двумя направлениями на плоскости (заданными соответствующими векторами).

- Проверка, лежат ли две заданные точки плоскости по одну сторону от заданной (с помощью неявной функции) границы области.

- Проверка, лежат ли две заданные точки плоскости по одну сторону от заданной прямой.

- Проверка, является ли заданный плоский многоугольник выпуклым.

- Проверка, лежит ли заданная точка плоскости внутри заданного выпуклого многоугольника (как было предложено в лекции 5).

- Проверка, лежит ли заданная точка плоскости внутри заданного многоугольника (не обязательно выпуклого, см. лекцию 6).

**Указание.** Для решения всех перечисленных выше задач, кроме последней, воспользоваться материалом лекции 5.

2. Написать функцию, реализующую алгоритм Джарвиса построения выпуклой оболочки заданных точек плоскости (см. лекцию 6).

3. Написать функцию, реализующую алгоритм Грехома построения выпуклой оболочки заданных точек плоскости (см. лекцию 6).

4. Написать функцию, возвращающую значение ориентированной площади заданного плоского многоугольника, воспользовавшись методом трапеций (см. лекцию 6).

5. Написать функцию, возвращающую значение ориентированной площади заданного плоского многоугольника, воспользовавшись методом треугольников (см. лекцию 6).

6. Пусть имеется некоторый выпуклый многоугольник (выпуклая оболочка некотрого множества точек плоскости) и дана ещё дна тока. Требуется написать функцию, строющую выпуклую оболочку множества точек, включающее также и эту новую точку.

**Замечание.** Если последняя задача решена, то тем самым фактически получен ещё один алгоритм построения выпуклой оболочки заданного множества точек. В самом деле, сначала можно взять какие-либо три точки из заданного множества, не лежащие на одной прямой, а затем останется только с помощью разработанной функции, поутем поочередного добавления всех остальных точек, построить искомую выпуклую оболочку.

Следует отметить, что такой алгоритм вычисляет индуктивную функцию, представляющую собой функцию, определенную на последовательностях точек, значениями которой являются соответсвующая выпуклая оболочка.

7. Реализовать построение выпуклой оболочки указанным выше способом.

**Указание.** При получении новой точки надо определить, является ли она внутренней или внешней точкой по отношению к уже имеющейся выпуклой оболочке. Если она оказалась внутренней, то выпуклая оболочка остается прежней. Если же точка оказалась внешней, то надо определить две "крайние" вершины прежней выпуклой оболочки, через каждую из которых можно провести из новой точки луч, таким образом, чтобы он не проходил через её внутренние точки. После этого остается только заменить соответствующую часть вершин ранее построенной выпуклой оболочки на одну новую вершину, и таким образом получить выпуклую оболочку, включающую её.

Алгоритм реализовать с использованием встроенной функции высшего порядка reduce.

8. Пусть в дополнение к условию задачи 6 известна площадь имеющейся выпуклой оболочки. Требуется аналогично задаче 7 реализовать вычисление индуктивной функции, возвращающей как саму выпуклую оболочку, так и ее площадь.

**Указание.** На каждом шаге алгоритма для вычисления приращения площади выпуклой оболочки использовать метод треугольников.

--------------------- Дополнительные задания
9. Написать функцию, проверяющую, явлется ли заданная последовательность точек (пердставленная типом Vector{Vector2D}), вершинами некоторого многоугольника (у многоугольника никакие две его стороны не пересекаются внутренним образом).
    
**Указание.** Воспользоваться ранее написанной функцией intersect, возвращающей координаты точки пересечения двух отрезков, если такая точка существует. При отсутствии точки пересечения функция возвращае или noting, или при её выполнении возникнет исключительная ситуации, если отрезки лежат на параллельных прямых. Эту возможную исключительную ситуацию следует перехватывать с помощью конструкции try-cath-end). Но прежде чем вызывать функцию intersect, следует проверить, являются ли в заданной последовательности точек все точки уникальными (в противном случае они заведомо не могут быть вершинами никакого многоугольника).

10. Написать функцию, вычисляющую выпуклую оболочку объединения некоторых двух множест точек плоскости, если заданы выпуклые оболочки каждого из них (сами множества считаются не заданными).

11. Написать функцию, вычисляющую выпуклую оболочку пересечения каких-либо двух множест точек плоскости, если заданы выпуклые оболочки каждого из них (сами множества считаются не заданными).

**Указание.** Сначала в каждую из двух заданных выпуклых оболочек добавить вершины, лежащие в точках пересечения их сторон, если, конечно, точки пересечения существуют и не совпадают с какой-либо уже имеющейся вершиной. Для поиска точек пересечения воспользоваться разработанной ранее функцией. Затем из каждой выпуклой оболочки удалить лишние вершины, а оставшиеся вершины в нужном порядке поместить в список вершин искомого пересечения.

**Замечание.** Имеется встроенная функция allunique, проверяющая уникальность элементов заданной последовательности. Также имеется функция unique, удаляющяю повторяющиеся элементы из заданного вектора.

# Практика 13

1. Научиться программировать все алгоритмы, разбиравшиеся в лекции 7.

2. Решить следующие задачи.

**Задача 1.** Составить цикл, генерирующий и печатающий последовательность всех размещений **без повторений** (можно обернуть его в соответствующую функцию).

**Указание.** Воспользоваться пользоательскими типами KSubset{M,K} и Permute{K} (см. лекцию 7).

**Задача 2.** Решить так называемую задачу **коммивояжера**, т.е. написать функцию, получающую на вход весовую матрицу некоторого ориентированного, вообще говоря, графа, и возвращающую двухэлементный кортеж, содержащий:
 1) последовательность вершин этого графа, определяющую цикл наименьшей "стоимости", включающий все вершины графа ровно по одному разу;
 2) "стоимость" этого цикла.
 
В этой задаче граф считается **простым**, т.е. не содержащем петель и кратных ребер.

Элементы весовой матрицы должны представлять собой произвольные вещественные числа с плавающей точкой (не обязательно положительные, вообще говоря).

**Замечание.** Цикл, содержащий все вершины графа ровно по одному разу, называется **гамильтоновом цикл**. Не в кажом графе существует гамильтонов цикл. Граф, содержащий гамильтонов цикл, называется **гамильтоновым графом**.

Каждый полный граф, очевидно, является гамильтоновым. 

Условие задачи предполагает, что рассматриваемый граф является гамильтоновым.

Если весовая матрица не содержит бескоечностей, то она определяет некоторый полный граф. Однако, если мы хотим рассматривать не только полные графы, то можно допустить, чтобы некоторые  элементы матриы были бы равными плюс бесконечности (`Inf=Inf64, Inf32, Inf16`), что фактически будет означать отсутствие соответствующих ребр. 

При этом, если окажется, что найденная минимальная стоимость равна плюс бесконечности, то это будет означать, что данный граф не является гамильтоновым.

**Указание.** Свести решение задачи коммивояжера к генерации  перестановок индексов вершин графа.

**Вопрос:** каково наименьшее необходимое число таких перестановок.
Из следующих вариантов ответа выберите правильный:

- $n!$
- $(n-1)!$
- $(n-1)!/2$

где n - число всех вершин.

Обоснуйте, почему в случае ориентированного графа правильным будет второй вариант, а в случае неориентированного графа - третий.

**Подсказка.**

Первый вариант приводит к тому, что каждый цикл будет повторяться ровно n раз, из за того, что в качестве "стартовой" вершины "старовых" будет рассмативаться каждая вершина по отдельности, но для цикла нет понятия "стартовая вершина".

**Второй вариант** фиксирует какую-то одну вершину в качестве стартовой, но допускает, рассмотрение каждого цикла вместе со своим противоположным циклом. Если граф неориентированный, то стоимости взаимно противоположных циклов будут одинаковые, а если граф ориентированый, то, вообще говоря, - нет.


**Замечание.** Задача коммивояжера относится к так называемому классу NP-трудных задач. Этот класс задач характеризуется тем, что для содержащихся в нем задач не известны алгоритмы полиномиальной сложности и, как предполагается специалистами (но на сегодняшний день это не доказано), не могут быть решены за $O(n^d)$ операций, где $n$ - размер задачи, $d$ - некоторое натуральное число.

Можно считать, что оценка сложности таких задач в зависимости от их размера растет или экспоненциально или как факториал.

Поэтому решить задачу комивояжера для сколько-нибудь больших значений n оказывается практически невозможным (на практике n придется ограничить всего несколькими десятками).  Однако существуют различные методы приближенного решения этой задачи, которые уже могут быть практически реализованы, но которые мы сейчас не рассмативаем.
# Практика 9

**Задача 1.** Написать функцию, реализующую "обратный ход" метода Гаусса, т.е. функцию, получающую на вход верхне-треугольную матрицу и вектор-столбец свободных членов, и возвращающую вектор-столбец решения соответствующей СЛАУ.

**Указание.** Решение задчи сводится к вычислениям по формуле:

$$
x[N-k] = \big(b[n-k]-A[n-k,n-k+1]x[N-k+1]-...-A[N-k,N]x[N]\big)/A[N-k,N-k]
$$
где $N$ - размер матрицы (квадратной), $k \in 0:N-1$.

Возможный вариант кода:

```julia
function reverse_gauss_1(A,b)
    x = similar(b)
    N = size(A, 1)
    for k in 0:N-1
        x[N-k] = (b[N-k] - sum(@view(A[N-k,N-k+1:N]) .* @view(x[N-k+1:N])))/A[N-k,N-k]
    end
    return x
end 
```

Оптимизированный вариант:

```julia
using LinearAlgebra

function reverse_gauss(Ab)
#Ab - транспонированная расширенная матрица 
    N = size(A, 2)
    x = Vector{eltype(Ab)}(undef,N)
   
    for k in 0:N-1
        x[N-k] = (Ab[N-k, N] - dot(@view(Ab[N-k+1:N, N-k]), @view(x[N-k+1:N])))/Ab[N-k,N-k]
    end
    return x
end 
```

Требуется с помощью макроса @time провести временные замеры для сравнения этих двух вариантов.
**Внимание.** Для получения  правильного результата ккаждая функция должна вызываться минимум дважду (время первого вызова будет включать также и время компиляции).

**Как формировать исходные данные для тестирования?**

Сформировать случайную верхнетреугольную матрицу можно следующим образом.

Имеет место
**Теорема** (о LU разложении). Любая невырожденная матрица A может быть представлена произведением матриц L и U, где L - нижнетреугольная матрица, U - верхнетреугольная матрица.

В пакете LinearAlgebra (он установлен в julia изначально) имеется функции lu, которая выполняет такое разложение входной матрицы.

С помощью этой функции можно генерировать случайную верхнетреугольную матрицу требуемого размера следующим образом.

```julia
using LinearAlgebra

function upper_triangular(N::Integer)
    A = randn(N)
    _, A = lu(A)
    return A
end
```

**Замечание.** Следующий код тоже будет генерировать случайные верхнетреугольные матрицы, однако эти матрицы могут оказаться чрезвычайно плохообусловленными. Такие матрицы не подходят для тестирования.

```julia
function upper_triangular(N::Integer)
    A = zeros(N,N)
    for i in 1:N
        A[i,i+1:N] = randn(N-i)
        A[i,i] = 1.0
    end
    return A
end
```

**Задача 2.** Написать функцию, реализующую приведение расширенной матрицы СЛАУ к ступенчатому виду.

**Указание.** При разработке алгоритма соблюсти следующие пункты:

- Должен осуществляться выбор ведущего элемента в столбце (для для этого можно использовать встроенную функцию высшего порядка `findmax`).

- Найденный ведущий элемент нужно проверить на "равенство" нулю, точнее говоря сравнить его абсолютную величину со значением, скажем, `1e-8`...`1e-6` - если она не превосходит этой величины, то матрицу нужно считать вырожденной. В этом случае нужно сгененровать исключительную ситуации с помощью встроенной функции `throw("Матрица СЛАУ вырождена")`.

- Поскольку в языке Julia матрица размещается в памяти по столбцам, то работать следует с транспонированной расширенной матрицей.

1. Сортирвка пузырьком. issorted, sortperm!, sort!. Сортирвка по значению функции. 

2. findall, findfirst, findlast, filter

3. Сортирвка столбцов матрицы по ключу. Срезы

4. Сортирвка подсчетом

5. Быстрый поиск в массиве

6. Вычисление значения многочлена и его производной в точке по схеме Горнера

7. Сортировка вставками

8. Циклический сдвиг на k позиций влево и вправо

9. Перестановки индексов, проверка, является ли вектор перестрановкой индексов (ispermute), обратна перестановка элементов массива (invpermute)

10. Прямая перестановка элементов массива (permute)

11. Однопроходный алгоритм вычисления СКО

12. Инвариант циекла. Быстрая сортировка Хоара

13. Инвариант цикла. Вычисление порядковых статистик и медианы массива методом Хоара

14. Вычисление первых k порядковых статистик O(N) (k ститать фиксированным и много меньшим N)

15. Двунаправленная пузырьковая сортировка

16. Сортировка Шелла

17. Сортировка расчесыванием

18. Сортировка слияниями

19. Инвапиант цикла. Быстрое возведение в степень

20. Инвариант цикла. Приближенное вычисление логарифма (не используя разоржения в ряд)

21. Инвариант цикла. Решение нелинейного уранения методом деления отрезка пополам.

22. Инвариант цикла. Расширенный алгоритм Евклида вычисления НОД

23. Проверка, является ли число простым

24. Вычисление всех простых чисел, не превосходящих заданного числа n методом решета Эратосфена 

25. Вычисление всех простых делителей числа и их кратностей

26. Приближенное решение нелинейного уравнения методом Ньютона. 

27. Применение метод Ньютона для приближенного вычисления комплексного корня многочлена

28. Проектирвание пользовательских типов. Пользовательский тип Polynomial{T} (частичная реализация методов)

29. Проектирвание пользовательских типов. Пользовательский тип Polynomial{T}, реализация метода divrem

30. Проектирвание пользовательских типов. Пользовательский тип Reside{T,M}

31. Вычисление частичных сумм степенного ряда, заданного формулой n-го члена, построение соответсвующих графиков

32. Численное суммирование степенного ряда с точностью до машинного эпсилон, заданного формулой n-го члена, построение соответсвующих графиков

33. Проектирвание пользовательских типов. Типданных Vector2D, обеспечивающий операции с векторами на плоскости, необходимые для решения задач по вычислительной геометрии, вычисление углов между прямыми (между направляющими векторами).

34. Задача вычисления координат точки пересечения (если она существует) двух отрезков на плоскости. Протестироват программу с построением графиков.

35. Проверка, лежат ли две заданные точки по додну сторону от заданной прямой. Проверка, лежат ли две заданные точки по одну сторону от неявно заданной кривой. Протестироват программу с построением графиков.

36. Задача определения, является ли заданный плоский многоугольник выпуклым. Протестироват программу с построением графиков.

37. Задача определения, лежит ли заданная точка плоскости внутри заданного выпуклого многоугольника. Протестироват программу с построением графиков.

38. Проверка, лежит ли заданная точка плоскости внутри заданного многоугольника, не обязательно выпуклого. Протестироват программу с построением графиков.

39. Написать функцию, реализующую алгоритм Джарвиса построения выпуклой оболочки заданных точек плоскости. Протестироват программу с построением графиков.

40. Написать функцию, реализующую алгоритм Грехома построения выпуклой оболочки заданных точек плоскости. Протестироват программу с построением графиков.

41. Написать функцию, возвращающую значение ориентированной площади заданного плоского многоугольника, воспользовавшись методом трапеций. Протестировать программу с построением графиков.

42. Написать функцию, возвращающую значение ориентированной площади заданного плоского многоугольника, воспользовавшись методом треугольников. Протестировать программу с построением графиков.

43. Пусть имеется некоторый выпуклый многоугольник (выпуклая оболочка некотрого множества точек плоскости) и дана ещё дна тока. Требуется написать функцию, строющую выпуклую оболочку множества точек, включающее также и эту новую точку. Протестировать программу с построением графиков.

44. Написать функцию, проверяющую, явлется ли заданная последовательность точек (пердставленная типом Vector{Vector2D}), вершинами некоторого многоугольника (у многоугольника никакие две его стороны не пересекаются внутренним образом). Протестировать программу с построением графиков.
    
**Указание.** Воспользоваться ранее написанной функцией intersect, возвращающей координаты точки пересечения двух отрезков, если такая точка существует. При отсутствии точки пересечения функция возвращае или noting, или при её выполнении возникнет исключительная ситуации, если отрезки лежат на параллельных прямых. Эту возможную исключительную ситуацию следует перехватывать с помощью конструкции try-cath-end). Но прежде чем вызывать функцию intersect, следует проверить, являются ли в заданной последовательности точек все точки уникальными (в противном случае они заведомо не могут быть вершинами никакого многоугольника).

45. Написать функцию, вычисляющую выпуклую оболочку объединения некоторых двух множест точек плоскости, если заданы выпуклые оболочки каждого из них (сами множества считаются не заданными). Протестировать программу с построением графиков.

46. Написать функцию, вычисляющую выпуклую оболочку пересечения каких-либо двух множеств точек плоскости, если заданы выпуклые оболочки каждого из них (сами множества считаются не заданными). Протестировать программу с построением графиков.

47. Генерирование всех размещений с повторениями из n элементов {1,2,...,n} по k в лексикографическом порядке. Проектирвание пользовательских типов данных, итераторы.

48. Генерация вcех перестановок 1,2,...,n в лексикографическом порядке. Проектирвание пользовательский типов данных, итераторы.

49. Генерация всех всех подмножеств n-элементного множества {1,2,...,n} в лексикографическом порядке. Проектирвание пользовательских типов данных, итераторы.

50. Генерация всех всех k-элементных подмножеств n-элементного множества {1,2,...,n} в лексикографическом порядке. Проектирвание пользовательских типов данных, итераторы.

51. Генерирование всех размещений без повторений из n элементов {1,2,...,n} по k в лексикографическом порядке. Проектирвание пользовательских типов данных, итераторы.

52. Генерация всех разбиений натурального числа на положительные слагаемые. Проектирвание пользовательских типов данных, итераторы.

53. Решение задачи коммивояжера полным перебором для полного графа, заданного весовой матрицей.

54. Проверка, является ли заданный матрицей смежности граф гамильтоновым. (Указание: нули в матрице смежности заменить бесконечностями, и, считая полученную матрицу весовой, решить задачу коммивояжера).






